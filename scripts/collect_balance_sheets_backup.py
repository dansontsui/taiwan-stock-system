#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n"""\n資產負債表資料收集腳本\n"""\n\nimport sys\nimport os\nimport time\nimport argparse\nimport warnings\nfrom datetime import datetime, timedelta\nimport pandas as pd\n# from tqdm import tqdm  # 暫時註解掉避免依賴問題\n\n# 隱藏 DeprecationWarning\nwarnings.filterwarnings("ignore", category=DeprecationWarning)\n\n# 添加專案根目錄到 Python 路徑\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom config import Config\nfrom app.utils.simple_database import SimpleDatabaseManager as DatabaseManager\nfrom app.services.data_collector import FinMindDataCollector\nfrom loguru import logger\n\n# 簡化的API狀態檢查\ndef is_api_limit_error(error_msg):\n    """檢查是否為API限制錯誤"""\n    api_limit_keywords = ["402", "Payment Required", "API請求限制", "rate limit", "quota exceeded"]\n    return any(keyword.lower() in error_msg.lower() for keyword in api_limit_keywords)\n\ndef wait_for_api_recovery(stock_id="2330", dataset="TaiwanStockPrice"):\n    """等待API恢復正常 - 每5分鐘檢查一次"""\n    import requests\n    from datetime import datetime, timedelta\n    \n    print("=" * 60)\n    print("🚫 API請求限制偵測 - 開始每5分鐘檢查API狀態")\n    print("=" * 60)\n    \n    check_count = 0\n    while True:\n        check_count += 1\n        current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        print(f"⏰ [{current_time}] 第 {check_count} 次檢查API狀態...")\n        \n        try:\n            # 使用簡單的API請求測試狀態\n            test_url = "https://api.finmindtrade.com/api/v4/data"\n            yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')\n            \n            test_params = {\n                "dataset": dataset,\n                "data_id": stock_id,\n                "start_date": yesterday,\n                "end_date": yesterday,\n                "token": ""  # 使用免費額度測試\n            }\n            \n            response = requests.get(test_url, params=test_params, timeout=10)\n            \n            if response.status_code == 200:\n                print(f"✅ [{datetime.now().strftime('%H:%M:%S')}] API已恢復正常，繼續執行")\n                print("=" * 60)\n                return True\n            elif response.status_code == 402:\n                print(f"❌ API仍然受限 (402)，5分鐘後再次檢查...")\n            else:\n                print(f"⚠️ API狀態碼: {response.status_code}，5分鐘後再次檢查...")\n                \n        except Exception as e:\n            print(f"⚠️ 檢查API狀態時發生錯誤: {e}，5分鐘後再次檢查...")\n        \n        # 等待5分鐘\n        print("⏳ 等待5分鐘...")\n        for i in range(5):\n            remaining = 5 - i\n            print(f"\r   剩餘 {remaining} 分鐘...", end="", flush=True)\n            time.sleep(60)\n        print()  # 換行\n\ndef init_logging():\n    """初始化日誌"""\n    log_dir = os.path.join(Config.BASE_DIR, 'logs')\n    if not os.path.exists(log_dir):\n        os.makedirs(log_dir)\n    \n    logger.add(\n        os.path.join(log_dir, 'collect_balance_sheets.log'),\n        rotation="50 MB",\n        retention="30 days",\n        level="INFO"\n    )\n\ndef get_balance_sheet_data(collector, stock_id, start_date, end_date):\n    """獲取資產負債表資料"""\n    try:\n        data = collector._make_request(\n            dataset="TaiwanStockBalanceSheet",\n            data_id=stock_id,\n            start_date=start_date,\n            end_date=end_date\n        )\n        \n        if data and 'data' in data and data['data']:\n            df = pd.DataFrame(data['data'])\n            logger.info(f"股票 {stock_id} 獲取到 {len(df)} 筆資產負債表資料")\n            return df\n        else:\n            logger.warning(f"股票 {stock_id} 無資產負債表資料")\n            return None\n            \n    except Exception as e:\n        error_msg = str(e)\n        if "402" in error_msg or "Payment Required" in error_msg:\n            raise Exception(f"API請求限制: {error_msg}")\n        logger.error(f"獲取股票 {stock_id} 資產負債表資料失敗: {e}")\n        return None\n\ndef save_balance_sheet_data(db_manager, df, stock_id):\n    """儲存資產負債表資料"""\n    if df is None or df.empty:\n        return 0\n    \n    conn = db_manager.get_connection()\n    cursor = conn.cursor()\n    \n    saved_count = 0\n    \n    try:\n        for _, row in df.iterrows():\n            try:\n                cursor.execute("""\n                    INSERT OR REPLACE INTO balance_sheets \n                    (stock_id, date, type, value, origin_name, created_at)\n                    VALUES (?, ?, ?, ?, ?, ?)\n                """, (\n                    row['stock_id'],\n                    row['date'],\n                    row['type'],\n                    row['value'],\n                    row.get('origin_name', ''),\n                    datetime.now()\n                ))\n                saved_count += 1\n                \n            except Exception as e:\n                logger.warning(f"儲存資產負債表資料失敗 {stock_id} {row.get('date', 'N/A')} {row.get('type', 'N/A')}: {e}")\n                continue\n        \n        conn.commit()\n        logger.info(f"股票 {stock_id} 成功儲存 {saved_count} 筆資產負債表資料")\n        \n    except Exception as e:\n        logger.error(f"儲存資產負債表資料時發生錯誤: {e}")\n        conn.rollback()\n        \n    finally:\n        conn.close()\n    \n    return saved_count\n\ndef calculate_balance_sheet_ratios(db_manager, stock_id):\n    """計算資產負債表相關比率"""\n    conn = db_manager.get_connection()\n    cursor = conn.cursor()\n    \n    try:\n        cursor.execute("""\n            SELECT date, type, value\n            FROM balance_sheets \n            WHERE stock_id = ?\n            ORDER BY date, type\n        """, (stock_id,))\n        \n        data = cursor.fetchall()\n        \n        if not data:\n            return 0\n        \n        # 按日期分組處理\n        date_groups = {}\n        for date, type_name, value in data:\n            if date not in date_groups:\n                date_groups[date] = {}\n            date_groups[date][type_name] = value\n        \n        updated_count = 0\n        \n        for date, metrics in date_groups.items():\n            # 計算關鍵財務比率\n            total_assets = metrics.get('TotalAssets', 0)\n            total_liabilities = metrics.get('TotalLiabilities', 0)\n            current_assets = metrics.get('CurrentAssets', 0)\n            current_liabilities = metrics.get('CurrentLiabilities', 0)\n            \n            # 計算比率\n            debt_ratio = None\n            current_ratio = None\n            \n            if total_assets and total_assets > 0:\n                if total_liabilities:\n                    debt_ratio = (total_liabilities / total_assets) * 100\n            \n            if current_liabilities and current_liabilities > 0:\n                if current_assets:\n                    current_ratio = current_assets / current_liabilities\n            \n            # 更新財務比率表\n            if debt_ratio is not None or current_ratio is not None:\n                cursor.execute("""\n                    INSERT OR REPLACE INTO financial_ratios \n                    (stock_id, date, debt_ratio, current_ratio, created_at)\n                    VALUES (?, ?, ?, ?, ?)\n                    ON CONFLICT(stock_id, date) DO UPDATE SET\n                    debt_ratio = COALESCE(excluded.debt_ratio, debt_ratio),\n                    current_ratio = COALESCE(excluded.current_ratio, current_ratio)\n                """, (\n                    stock_id, date, debt_ratio, current_ratio, datetime.now()\n                ))\n                updated_count += 1\n        \n        conn.commit()\n        logger.info(f"股票 {stock_id} 資產負債表比率計算完成，更新 {updated_count} 筆記錄")\n        return updated_count\n        \n    except Exception as e:\n        logger.error(f"計算資產負債表比率失敗 {stock_id}: {e}")\n        conn.rollback()\n        return 0\n    finally:\n        conn.close()\n\ndef collect_balance_sheet_batch(stock_list, start_date, end_date, batch_size=3):\n    """批次收集資產負債表資料"""\n    print(f" 開始收集資產負債表資料")\n    print(f" 日期範圍: {start_date} ~ {end_date}")\n    print(f" 股票數量: {len(stock_list)}")\n    print(f" 批次大小: {batch_size}")\n    print("=" * 60)\n    \n    db_manager = DatabaseManager(Config.DATABASE_PATH)\n    collector = FinMindDataCollector(\n        api_url=Config.FINMIND_API_URL,\n        api_token=Config.FINMIND_API_TOKEN\n    )\n    \n    total_saved = 0\n    total_ratios = 0\n    failed_stocks = []\n    \n    total_batches = (len(stock_list) + batch_size - 1) // batch_size\n    for batch_idx, i in enumerate(range(0, len(stock_list), batch_size), 1):\n        batch = stock_list[i:i + batch_size]\n        print(f"處理批次 {batch_idx}/{total_batches} ({len(batch)} 檔股票)")\n        \n        for stock in batch:\n            stock_id = stock['stock_id']\n            stock_name = stock.get('stock_name', stock_id)\n            \n            try:\n                print(f" 收集 {stock_id} ({stock_name}) 資產負債表資料...")\n                \n                df = get_balance_sheet_data(collector, stock_id, start_date, end_date)\n                \n                if df is not None and not df.empty:\n                    saved_count = save_balance_sheet_data(db_manager, df, stock_id)\n                    total_saved += saved_count\n                    \n                    ratio_count = calculate_balance_sheet_ratios(db_manager, stock_id)\n                    total_ratios += ratio_count\n                    \n                    print(f" {stock_id} 完成，儲存 {saved_count} 筆資料，計算 {ratio_count} 筆比率")\n                else:\n                    print(f"  {stock_id} 無資料")\n                \n                time.sleep(2)\n\n            except KeyboardInterrupt:\n                print(f"\n⚠️ 使用者中斷執行，已處理 {processed_count}/{total_stocks} 檔股票")\n                logger.info(f"使用者中斷執行，已處理 {processed_count}/{total_stocks} 檔股票")\n                break  # 跳出迴圈，返回已收集的結果\n            except Exception as e:\n                error_msg = str(e)\n                print(f" {stock_id} 失敗: {error_msg}")\n                logger.error(f"收集 {stock_id} 資產負債表失敗: {error_msg}")\n                failed_stocks.append((stock_id, error_msg))\n                \n                # 如果是API限制錯誤，智能等待\n                if is_api_limit_error(error_msg):\n                    wait_for_api_recovery(stock_id, dataset)\n                else:\n                    time.sleep(5)\n        \n        if i + batch_size < len(stock_list):\n            print(f"  批次完成，休息15秒...")\n            time.sleep(15)\n    \n    print("\n" + "=" * 60)\n    print(" 資產負債表資料收集完成")\n    print("=" * 60)\n    print(f" 成功收集: {len(stock_list) - len(failed_stocks)} 檔股票")\n    print(f" 總儲存筆數: {total_saved}")\n    print(f" 財務比率筆數: {total_ratios}")\n    print(f" 失敗股票: {len(failed_stocks)} 檔")\n    \n    return total_saved, total_ratios, failed_stocks\n\ndef main():\n    """主函數"""\n    # 確保 datetime 在函數作用域中可用\n    from datetime import datetime as dt\n\n    parser = argparse.ArgumentParser(description='收集台股資產負債表資料')\n    parser.add_argument('--start-date', default='2020-01-01', help='開始日期')\n    parser.add_argument('--end-date', default=dt.now().strftime('%Y-%m-%d'), help='結束日期')\n    parser.add_argument('--batch-size', type=int, default=3, help='批次大小')\n    parser.add_argument('--test', action='store_true', help='測試模式')\n    parser.add_argument('--stock-id', help='指定股票代碼')\n\n    args = parser.parse_args()\n\n    print("=" * 60)\n    if args.stock_id:\n        print(f"台股資產負債表資料收集系統 - 個股 {args.stock_id}")\n    else:\n        print("台股資產負債表資料收集系統")\n    print("=" * 60)\n\n    init_logging()\n    logger.info("開始收集資產負債表資料")\n\n    # 不再預先初始化計時器，只在遇到API限制時才開始檢查\n\n    try:\n        db_manager = DatabaseManager(Config.DATABASE_PATH)\n        conn = db_manager.get_connection()\n        cursor = conn.cursor()\n\n        if args.stock_id:\n            # 指定個股\n            cursor.execute("""\n                SELECT stock_id, stock_name\n                FROM stocks\n                WHERE stock_id = ?\n            """, (args.stock_id,))\n            stock_list = [{'stock_id': row[0], 'stock_name': row[1]} for row in cursor.fetchall()]\n        else:\n            cursor.execute("""\n                SELECT stock_id, stock_name\n                FROM stocks\n                WHERE is_etf = 0\n                AND LENGTH(stock_id) = 4\n                AND stock_id GLOB '[0-9][0-9][0-9][0-9]'\n                AND market IN ('TWSE', 'TPEx')\n                ORDER BY stock_id\n            """)\n            stock_list = [{'stock_id': row[0], 'stock_name': row[1]} for row in cursor.fetchall()]\n\n        conn.close()\n\n        if args.test and not args.stock_id:\n            stock_list = stock_list[:3]\n            print(" 測試模式：只收集前3檔股票")\n\n        if not stock_list:\n            if args.stock_id:\n                print(f" 找不到股票代碼: {args.stock_id}")\n            else:\n                print(" 未找到股票資料")\n            return\n        \n        total_saved, total_ratios, failed_stocks = collect_balance_sheet_batch(\n            stock_list=stock_list,\n            start_date=args.start_date,\n            end_date=args.end_date,\n            batch_size=args.batch_size\n        )\n        \n        logger.info(f"資產負債表資料收集完成，共儲存 {total_saved} 筆資料，計算 {total_ratios} 筆比率")\n\n    except KeyboardInterrupt:\n        print(f"\n⚠️ 資產負債表資料收集已被使用者中斷")\n        logger.info("資產負債表資料收集已被使用者中斷")\n        sys.exit(0)  # 正常退出，不是錯誤\n    except Exception as e:\n        error_msg = f"資產負債表資料收集失敗: {e}"\n        print(f" {error_msg}")\n        logger.error(error_msg)\n        sys.exit(1)\n\nif __name__ == "__main__":\n    main()\n