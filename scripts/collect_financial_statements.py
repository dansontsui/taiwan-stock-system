#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n"""\n綜合損益表資料收集腳本\n"""\n\nimport sys\nimport os\nimport time\nimport argparse\nimport warnings\nfrom datetime import datetime, timedelta\nimport pandas as pd\n# from tqdm import tqdm  # 暫時註解掉避免依賴問題\n\n# 隱藏 DeprecationWarning\nwarnings.filterwarnings("ignore", category=DeprecationWarning)\n\n# 添加專案根目錄到 Python 路徑\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom config import Config\nfrom app.utils.simple_database import SimpleDatabaseManager as DatabaseManager\nfrom app.services.data_collector import FinMindDataCollector\nfrom loguru import logger\n\n# 簡化的API狀態檢查\ndef is_api_limit_error(error_msg):\n    """檢查是否為API限制錯誤"""\n    api_limit_keywords = ["402", "Payment Required", "API請求限制", "rate limit", "quota exceeded"]\n    return any(keyword.lower() in error_msg.lower() for keyword in api_limit_keywords)\n\ndef wait_for_api_recovery(stock_id="2330", dataset="TaiwanStockPrice"):\n    """等待API恢復正常 - 每5分鐘檢查一次"""\n    import requests\n    from datetime import datetime, timedelta\n    \n    print("=" * 60)\n    print("🚫 API請求限制偵測 - 開始每5分鐘檢查API狀態")\n    print("=" * 60)\n    \n    check_count = 0\n    while True:\n        check_count += 1\n        current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        print(f"⏰ [{current_time}] 第 {check_count} 次檢查API狀態...")\n        \n        try:\n            # 使用簡單的API請求測試狀態\n            test_url = "https://api.finmindtrade.com/api/v4/data"\n            yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')\n            \n            test_params = {\n                "dataset": dataset,\n                "data_id": stock_id,\n                "start_date": yesterday,\n                "end_date": yesterday,\n                "token": ""  # 使用免費額度測試\n            }\n            \n            response = requests.get(test_url, params=test_params, timeout=10)\n            \n            if response.status_code == 200:\n                print(f"✅ [{datetime.now().strftime('%H:%M:%S')}] API已恢復正常，繼續執行")\n                print("=" * 60)\n                return True\n            elif response.status_code == 402:\n                print(f"❌ API仍然受限 (402)，5分鐘後再次檢查...")\n            else:\n                print(f"⚠️ API狀態碼: {response.status_code}，5分鐘後再次檢查...")\n                \n        except Exception as e:\n            print(f"⚠️ 檢查API狀態時發生錯誤: {e}，5分鐘後再次檢查...")\n        \n        # 等待5分鐘\n        print("⏳ 等待5分鐘...")\n        for i in range(5):\n            remaining = 5 - i\n            print(f"\r   剩餘 {remaining} 分鐘...", end="", flush=True)\n            time.sleep(60)\n        print()  # 換行\n\ndef init_logging():\n    """初始化日誌"""\n    log_dir = os.path.join(Config.BASE_DIR, 'logs')\n    if not os.path.exists(log_dir):\n        os.makedirs(log_dir)\n\n    logger.add(\n        os.path.join(log_dir, 'collect_financial_statements.log'),\n        rotation="50 MB",\n        retention="30 days",\n        level="INFO"\n    )\n\ndef get_financial_statements_data(collector, stock_id, start_date, end_date):\n    """獲取單一股票的綜合損益表資料"""\n    try:\n        # 使用FinMind API獲取綜合損益表資料\n        data = collector._make_request(\n            dataset="TaiwanStockFinancialStatements",\n            data_id=stock_id,\n            start_date=start_date,\n            end_date=end_date\n        )\n        \n        if data and 'data' in data and data['data']:\n            df = pd.DataFrame(data['data'])\n            logger.info(f"股票 {stock_id} 獲取到 {len(df)} 筆綜合損益表資料")\n            return df\n        else:\n            logger.warning(f"股票 {stock_id} 無綜合損益表資料")\n            return None\n            \n    except Exception as e:\n        logger.error(f"獲取股票 {stock_id} 綜合損益表資料失敗: {e}")\n        return None\n\ndef save_financial_statements_data(db_manager, df, stock_id):\n    """儲存綜合損益表資料到資料庫"""\n    if df is None or df.empty:\n        return 0\n    \n    conn = db_manager.get_connection()\n    cursor = conn.cursor()\n    \n    saved_count = 0\n    \n    try:\n        for _, row in df.iterrows():\n            try:\n                cursor.execute("""\n                    INSERT OR REPLACE INTO financial_statements \n                    (stock_id, date, type, value, origin_name, created_at)\n                    VALUES (?, ?, ?, ?, ?, ?)\n                """, (\n                    row['stock_id'],\n                    row['date'],\n                    row['type'],\n                    row['value'],\n                    row.get('origin_name', ''),\n                    datetime.now()\n                ))\n                saved_count += 1\n                \n            except Exception as e:\n                logger.warning(f"儲存綜合損益表資料失敗 {stock_id} {row.get('date', 'N/A')} {row.get('type', 'N/A')}: {e}")\n                continue\n        \n        conn.commit()\n        logger.info(f"股票 {stock_id} 成功儲存 {saved_count} 筆綜合損益表資料")\n        \n    except Exception as e:\n        logger.error(f"儲存綜合損益表資料時發生錯誤: {e}")\n        conn.rollback()\n        \n    finally:\n        conn.close()\n    \n    return saved_count\n\ndef calculate_financial_ratios(db_manager, stock_id):\n    """計算財務比率"""\n    conn = db_manager.get_connection()\n    cursor = conn.cursor()\n    \n    try:\n        # 獲取該股票的綜合損益表資料，按日期分組\n        cursor.execute("""\n            SELECT date, type, value\n            FROM financial_statements \n            WHERE stock_id = ?\n            ORDER BY date, type\n        """, (stock_id,))\n        \n        data = cursor.fetchall()\n        \n        if not data:\n            return 0\n        \n        # 按日期分組處理\n        date_groups = {}\n        for date, type_name, value in data:\n            if date not in date_groups:\n                date_groups[date] = {}\n            date_groups[date][type_name] = value\n        \n        updated_count = 0\n        \n        for date, metrics in date_groups.items():\n            # 計算關鍵財務比率\n            revenue = metrics.get('Revenue', 0)\n            cost_of_goods = metrics.get('CostOfGoodsSold', 0)\n            gross_profit = metrics.get('GrossProfit', 0)\n            operating_income = metrics.get('OperatingIncome', 0)\n            net_income = metrics.get('IncomeAfterTaxes', 0)\n            \n            # 計算比率\n            gross_margin = None\n            operating_margin = None\n            net_margin = None\n            \n            if revenue and revenue > 0:\n                if gross_profit:\n                    gross_margin = (gross_profit / revenue) * 100\n                if operating_income:\n                    operating_margin = (operating_income / revenue) * 100\n                if net_income:\n                    net_margin = (net_income / revenue) * 100\n            \n            # 儲存到財務比率表\n            if any([gross_margin, operating_margin, net_margin]):\n                cursor.execute("""\n                    INSERT OR REPLACE INTO financial_ratios \n                    (stock_id, date, gross_margin, operating_margin, net_margin, created_at)\n                    VALUES (?, ?, ?, ?, ?, ?)\n                """, (\n                    stock_id, date, gross_margin, operating_margin, net_margin, datetime.now()\n                ))\n                updated_count += 1\n        \n        conn.commit()\n        logger.info(f"股票 {stock_id} 財務比率計算完成，更新 {updated_count} 筆記錄")\n        return updated_count\n        \n    except Exception as e:\n        logger.error(f"計算財務比率失敗 {stock_id}: {e}")\n        conn.rollback()\n        return 0\n    finally:\n        conn.close()\n\ndef collect_financial_statements_batch(stock_list, start_date, end_date, batch_size=5):\n    """批次收集綜合損益表資料"""\n    print(f" 開始收集綜合損益表資料")\n    print(f" 日期範圍: {start_date} ~ {end_date}")\n    print(f" 股票數量: {len(stock_list)}")\n    print(f" 批次大小: {batch_size}")\n    print("=" * 60)\n    \n    # 初始化\n    db_manager = DatabaseManager(Config.DATABASE_PATH)\n    collector = FinMindDataCollector(\n        api_url=Config.FINMIND_API_URL,\n        api_token=Config.FINMIND_API_TOKEN\n    )\n    \n    total_saved = 0\n    total_ratios = 0\n    failed_stocks = []\n    \n    # 分批處理\n    total_batches = (len(stock_list) + batch_size - 1) // batch_size\n    for batch_idx, i in enumerate(range(0, len(stock_list), batch_size), 1):\n        batch = stock_list[i:i + batch_size]\n        print(f"處理批次 {batch_idx}/{total_batches} ({len(batch)} 檔股票)")\n        \n        for stock in batch:\n            stock_id = stock['stock_id']\n            stock_name = stock.get('stock_name', stock_id)\n            \n            try:\n                print(f" 收集 {stock_id} ({stock_name}) 綜合損益表資料...")\n                \n                # 獲取綜合損益表資料\n                df = get_financial_statements_data(collector, stock_id, start_date, end_date)\n                \n                if df is not None and not df.empty:\n                    # 儲存資料\n                    saved_count = save_financial_statements_data(db_manager, df, stock_id)\n                    total_saved += saved_count\n                    \n                    # 計算財務比率\n                    ratio_count = calculate_financial_ratios(db_manager, stock_id)\n                    total_ratios += ratio_count\n                    \n                    print(f" {stock_id} 完成，儲存 {saved_count} 筆資料，計算 {ratio_count} 筆比率")\n                else:\n                    print(f"  {stock_id} 無資料")\n                \n                # 控制請求頻率\n                time.sleep(1)\n                \n            except Exception as e:\n                error_msg = str(e)\n                print(f" {stock_id} 失敗: {error_msg}")\n                logger.error(f"收集 {stock_id} 綜合損益表失敗: {error_msg}")\n                failed_stocks.append((stock_id, error_msg))\n                \n                # 如果是API限制錯誤，智能等待\n                if is_api_limit_error(error_msg):\n                    wait_for_api_recovery(stock_id, dataset)\n                else:\n                    time.sleep(3)\n        \n        # 批次間休息\n        if i + batch_size < len(stock_list):\n            print(f"  批次完成，休息10秒...")\n            time.sleep(10)\n    \n    # 顯示結果\n    print("\n" + "=" * 60)\n    print(" 綜合損益表資料收集完成")\n    print("=" * 60)\n    print(f" 成功收集: {len(stock_list) - len(failed_stocks)} 檔股票")\n    print(f" 總儲存筆數: {total_saved}")\n    print(f" 財務比率筆數: {total_ratios}")\n    print(f" 失敗股票: {len(failed_stocks)} 檔")\n    \n    if failed_stocks:\n        print("\n失敗股票清單:")\n        for stock_id, error in failed_stocks[:10]:  # 只顯示前10個\n            print(f"  {stock_id}: {error}")\n        if len(failed_stocks) > 10:\n            print(f"  ... 還有 {len(failed_stocks) - 10} 檔")\n    \n    return total_saved, total_ratios, failed_stocks\n\ndef show_sample_data(db_manager, limit=5):\n    """顯示範例資料"""\n    conn = db_manager.get_connection()\n    cursor = conn.cursor()\n    \n    try:\n        print("\n 綜合損益表資料範例:")\n        print("-" * 60)\n        \n        cursor.execute("""\n            SELECT stock_id, date, type, value, origin_name\n            FROM financial_statements \n            WHERE type IN ('Revenue', 'GrossProfit', 'OperatingIncome', 'IncomeAfterTaxes', 'EPS')\n            ORDER BY stock_id, date DESC, type\n            LIMIT ?\n        """, (limit * 5,))\n        \n        for row in cursor.fetchall():\n            stock_id, date, type_name, value, origin_name = row\n            print(f"{stock_id} {date} {type_name:<20} {value:>15,.0f} ({origin_name})")\n        \n        print("\n 財務比率資料範例:")\n        print("-" * 60)\n        \n        cursor.execute("""\n            SELECT stock_id, date, gross_margin, operating_margin, net_margin\n            FROM financial_ratios \n            ORDER BY stock_id, date DESC\n            LIMIT ?\n        """, (limit,))\n        \n        for row in cursor.fetchall():\n            stock_id, date, gross_margin, operating_margin, net_margin = row\n            print(f"{stock_id} {date} 毛利率:{gross_margin or 0:>6.1f}% 營業利益率:{operating_margin or 0:>6.1f}% 淨利率:{net_margin or 0:>6.1f}%")\n        \n    except Exception as e:\n        print(f"顯示範例資料失敗: {e}")\n    finally:\n        conn.close()\n\ndef main():\n    """主函數"""\n    # 確保 datetime 在函數作用域中可用\n    from datetime import datetime as dt\n\n    parser = argparse.ArgumentParser(description='收集台股綜合損益表資料')\n    parser.add_argument('--start-date', default='2020-01-01', help='開始日期 (YYYY-MM-DD)')\n    parser.add_argument('--end-date', default=dt.now().strftime('%Y-%m-%d'), help='結束日期 (YYYY-MM-DD)')\n    parser.add_argument('--batch-size', type=int, default=5, help='批次大小')\n    parser.add_argument('--test', action='store_true', help='測試模式 (只收集前5檔股票)')\n    parser.add_argument('--stock-id', help='指定股票代碼')\n\n    args = parser.parse_args()\n\n    print("=" * 60)\n    if args.stock_id:\n        print(f"台股綜合損益表資料收集系統 - 個股 {args.stock_id}")\n    else:\n        print("台股綜合損益表資料收集系統")\n    print("=" * 60)\n\n    # 初始化日誌\n    init_logging()\n    logger.info("開始收集綜合損益表資料")\n\n    # 不再預先初始化計時器，只在遇到API限制時才開始檢查\n\n    try:\n        # 獲取股票清單\n        db_manager = DatabaseManager(Config.DATABASE_PATH)\n        conn = db_manager.get_connection()\n        cursor = conn.cursor()\n\n        if args.stock_id:\n            # 指定個股\n            cursor.execute("""\n                SELECT stock_id, stock_name\n                FROM stocks\n                WHERE stock_id = ?\n            """, (args.stock_id,))\n            stock_list = [{'stock_id': row[0], 'stock_name': row[1]} for row in cursor.fetchall()]\n        else:\n            # 只選擇真正的上市公司股票 (4位數字股票代碼)\n            cursor.execute("""\n                SELECT stock_id, stock_name\n                FROM stocks\n                WHERE is_etf = 0\n                AND LENGTH(stock_id) = 4\n                AND stock_id GLOB '[0-9][0-9][0-9][0-9]'\n                AND market IN ('TWSE', 'TPEx')\n                ORDER BY stock_id\n            """)\n            stock_list = [{'stock_id': row[0], 'stock_name': row[1]} for row in cursor.fetchall()]\n\n        conn.close()\n\n        if args.test and not args.stock_id:\n            stock_list = stock_list[:5]\n            print(" 測試模式：只收集前5檔股票")\n\n        if not stock_list:\n            if args.stock_id:\n                print(f" 找不到股票代碼: {args.stock_id}")\n            else:\n                print(" 未找到股票資料，請先執行股票清單收集")\n            return\n        \n        # 開始收集\n        total_saved, total_ratios, failed_stocks = collect_financial_statements_batch(\n            stock_list=stock_list,\n            start_date=args.start_date,\n            end_date=args.end_date,\n            batch_size=args.batch_size\n        )\n        \n        # 顯示範例資料\n        if total_saved > 0:\n            show_sample_data(db_manager)\n        \n        logger.info(f"綜合損益表資料收集完成，共儲存 {total_saved} 筆資料，計算 {total_ratios} 筆比率")\n        \n    except Exception as e:\n        error_msg = f"綜合損益表資料收集失敗: {e}"\n        print(f" {error_msg}")\n        logger.error(error_msg)\n        sys.exit(1)\n\nif __name__ == "__main__":\n    main()\n