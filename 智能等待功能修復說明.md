# 智能等待功能修復說明

## 問題分析

您正確指出了 `collect_financial_statements.py` 智能等待功能的問題：

### 原始問題
1. **固定等待時間**：每次都等待完整的70分鐘
2. **沒有執行時間追蹤**：不考慮已經執行的時間
3. **邏輯錯誤**：應該是 `等待時間 = 70分鐘 - 總執行時間`
4. **重置問題**：一旦開始執行，總執行時間沒有重置計算

### 實際影響
- 🚫 即使已經執行了60分鐘，還是會等待完整的70分鐘
- 🚫 總等待時間變成 130分鐘 (60執行 + 70等待)
- 🚫 效率極低，浪費大量時間

## 解決方案

### 1. 創建智能等待模組

創建了 `scripts/smart_wait.py` 模組，提供：

#### 核心功能
- ✅ **執行時間追蹤**：全局追蹤總執行時間
- ✅ **智能等待計算**：`等待時間 = 70分鐘 - 總執行時間`
- ✅ **自動重置機制**：等待完成後重置執行時間計時器
- ✅ **智能判斷**：如果已超過70分鐘，立即重置並繼續

#### 類別設計
```python
class SmartWaitManager:
    def __init__(self, api_reset_minutes=70)
    def reset_execution_timer()
    def get_execution_time_minutes()
    def smart_wait_for_api_reset()
    def is_api_limit_error(error_msg)
```

### 2. 修復 collect_financial_statements.py

#### 導入智能等待模組
```python
from scripts.smart_wait import reset_execution_timer, smart_wait_for_api_reset, is_api_limit_error
```

#### 在主函數開始時重置計時器
```python
def main():
    # 初始化日誌
    init_logging()
    logger.info("開始收集綜合損益表資料")
    
    # 重置執行時間計時器
    reset_execution_timer()
```

#### 使用智能等待
```python
# 如果是API限制錯誤，智能等待
if is_api_limit_error(error_msg):
    smart_wait_for_api_reset()
else:
    time.sleep(3)
```

## 智能等待邏輯

### 計算公式
```
實際等待時間 = max(0, 70分鐘 - 總執行時間)
```

### 執行流程
1. **開始執行**：重置執行時間計時器
2. **遇到API限制**：計算已執行時間
3. **智能等待**：只等待剩餘時間
4. **等待完成**：重置計時器，繼續執行

### 實際效果

| 執行時間 | 原始等待 | 智能等待 | 節省時間 |
|---------|---------|---------|---------|
| 0分鐘 | 70分鐘 | 70分鐘 | 0分鐘 |
| 30分鐘 | 70分鐘 | 40分鐘 | 30分鐘 |
| 60分鐘 | 70分鐘 | 10分鐘 | 60分鐘 |
| 80分鐘 | 70分鐘 | 0分鐘 | 70分鐘 |

## 詳細功能

### 1. 執行時間追蹤
```python
execution_start_time = datetime.now()  # 全局追蹤
```

### 2. 智能等待計算
```python
executed_minutes = get_execution_time_minutes()
remaining_wait_minutes = max(0, 70 - executed_minutes)
```

### 3. 進度顯示
```
🚫 API請求限制已達上限
============================================================
📊 執行統計:
   總執行時間: 30.5 分鐘
   API重置週期: 70 分鐘
   需要等待: 39.5 分鐘
============================================================
⏳ 智能等待 39.5 分鐘...
⏰ [10:24:30] 剩餘: 00:39:00 | 進度: 1.3%
```

### 4. 自動重置
```python
# 等待完成後自動重置
reset_execution_timer()
```

## 錯誤判斷改進

### 智能錯誤識別
```python
def is_api_limit_error(error_msg):
    api_limit_keywords = [
        "402", "Payment Required", "API請求限制", 
        "rate limit", "quota exceeded", "too many requests"
    ]
    return any(keyword.lower() in error_msg.lower() for keyword in api_limit_keywords)
```

### 使用方式
```python
# 原始方式
if "402" in error_msg or "Payment Required" in error_msg:

# 改進方式  
if is_api_limit_error(error_msg):
```

## 容錯處理

### 導入失敗處理
```python
try:
    from scripts.smart_wait import reset_execution_timer, smart_wait_for_api_reset
except ImportError:
    # 如果無法導入，使用本地版本
    print("[WARNING] 無法導入智能等待模組，使用本地版本")
    # 提供本地實現
```

### 向後兼容
```python
def wait_for_api_reset():
    """向後兼容的等待函數"""
    smart_wait_for_api_reset()
```

## 適用範圍

這個智能等待功能可以應用到所有使用 FinMind API 的收集腳本：

- ✅ `collect_financial_statements.py` - 已修復
- 🔄 `collect_balance_sheets.py` - 待修復
- 🔄 `collect_dividend_data.py` - 待修復
- 🔄 `collect_dividend_results.py` - 待修復

## 測試結果

✅ **所有測試通過**：
- 基本功能測試：執行時間追蹤、智能計算
- 整合功能測試：全局函數、錯誤判斷
- 錯誤識別測試：各種API限制錯誤格式

## 總結

### 解決的核心問題
1. ✅ **智能等待時間**：`等待時間 = 70分鐘 - 總執行時間`
2. ✅ **執行時間重置**：一旦開始執行，總執行時間重置計算
3. ✅ **效率提升**：大幅減少不必要的等待時間
4. ✅ **通用模組**：可應用到所有API收集腳本

### 實際效益
- 🚀 **效率提升**：最多可節省70分鐘等待時間
- 📊 **智能計算**：根據實際執行時間動態調整
- 🔄 **自動重置**：無需手動干預
- 📈 **進度顯示**：清晰的等待進度和統計資訊

現在的智能等待功能完全符合您的需求：**等待時間 = 70分鐘 - 總執行時間，一旦開始執行，總執行時間重置計算**！
