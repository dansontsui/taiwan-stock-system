# 快速參考：時間區間設計

## 🚀 一分鐘理解

### 核心原則
```
特徵資料 (過去) → 預測 → 目標變數 (未來)
     ↓              ↓           ↓
  2024-06-30    20個交易日    2024-07-30
```

## 📋 標準流程

### 1. 訓練階段
```bash
# 生成歷史特徵 (2022-2024)
python main.py generate-features --date 2024-06-30

# 生成對應目標變數 (2022-2024的未來結果)
python main.py generate-targets --start-date 2022-01-01 --end-date 2024-06-30 --frequency quarterly

# 訓練模型
python main.py train-models --features data/features/features_2024-06-30.csv --targets data/targets/targets_quarterly_2024-06-30.csv
```

### 2. 預測階段
```bash
# 生成當前特徵 (2025) - 只生成這一個日期的特徵
python main.py generate-features --date 2025-06-01

# 執行預測
python main.py predict --stock-id 2330 --date 2025-06-01
```

## 💡 重要澄清

### 單一日期 vs 批次生成
```bash
# ❌ 錯誤理解：
python main.py generate-features --date 2025-06-01
# 會生成2022-2025年所有特徵

# ✅ 正確理解：
python main.py generate-features --date 2025-06-01
# 只生成2025-06-01這一天的特徵
# 但會使用2023-06-01~2025-06-01的歷史資料計算
```

### 資料收集範圍
```
指定日期: 2025-06-01
資料收集: 2023-06-01 ~ 2025-06-01 (回看2年)
輸出結果: 1筆特徵記錄
```

## ⚠️ 常見錯誤

### ❌ 錯誤：用未來預測過去
```
特徵日期：2025-06-01
目標變數：2022-2024年  ← 錯誤！
```

### ✅ 正確：用過去預測未來
```
目標變數：2022-2024年  ← 訓練用
特徵日期：2025-06-01   ← 預測用
```

## 🎯 記憶口訣

**"過去訓練，當下預測，未來驗證"**

- 用**過去**的資料訓練模型
- 用**當下**的資料執行預測  
- 等**未來**的結果驗證準確性

## 📅 時間表範例

| 階段 | 特徵日期 | 目標日期 | 用途 |
|------|----------|----------|------|
| 訓練 | 2024-06-30 | 2024-07-30 | 學習規律 |
| 預測 | 2025-06-01 | 2025-07-01 | 實際預測 |
| 驗證 | - | 2025-07-01 | 檢查準確性 |

## 🚀 實際運作邏輯

### 預測時只需要一個日期
```bash
# ✅ 正確：只生成最新日期的特徵
python main.py generate-features --date 2024-12-30 --stock-ids 2330
python main.py predict --stock-id 2330 --date 2024-12-30
```

### 為什麼一個日期就夠？
```
2024-12-30的特徵已經包含：
├── RSI (14天) ← 最近14天的價格動能
├── 移動平均 (20天) ← 最近20天的價格趨勢
├── 營收成長率 ← 最近幾季的營收變化
├── 價格動量 ← 最近的價格變化
└── 成交量指標 ← 最近的交易活躍度

= 完整的市場狀態快照
```

### 什麼時候需要多個日期？

#### 訓練模型時（一次性）：
```bash
# 需要多個歷史日期
python main.py generate-features --date 2022-03-31
python main.py generate-features --date 2022-06-30
# ... 很多個日期
```

#### 日常預測時（經常性）：
```bash
# 只需要最新的一個日期
python main.py generate-features --date 2024-12-30
```

### 更新頻率建議
```bash
# 每週預測
python main.py generate-features --date 2025-01-07
python main.py generate-features --date 2025-01-14

# 每月預測
python main.py generate-features --date 2025-01-31
python main.py generate-features --date 2025-02-28
```

## 💡 核心記憶點

**預測時**：只生成最新日期的特徵（1個日期）
**這個特徵**：已包含所有需要的歷史資訊
**更新頻率**：想多常預測就多常生成新特徵

**不需要每個月都生成，只需要在想預測時生成最新的那一天！**

---
**關鍵：永遠確保特徵日期 < 目標日期**
如果您想每週預測一次：
# 第1週
python main.py generate-features --date 2025-01-07
python main.py predict --stock-id 2330 --date 2025-01-07

# 第2週  
python main.py generate-features --date 2025-01-14
python main.py predict --stock-id 2330 --date 2025-01-14

# 第3週
python main.py generate-features --date 2025-01-21
python main.py predict --stock-id 2330 --date 2025-01-21


如果您想每月預測一次：
# 1月預測
python main.py generate-features --date 2025-01-31
python main.py predict --stock-id 2330 --date 2025-01-31

# 2月預測
python main.py generate-features --date 2025-02-28  
python main.py predict --stock-id 2330 --date 2025-02-28

為何模型不是依據股票建立各自模型??
但特徵 跟 預測 卻是針對股票??


這是一個非常好的問題！您觸及了機器學習模型設計的核心概念。讓我詳細解釋為什麼是這樣設計的。

🎯 為什麼不是每個股票建立各自模型？
當前設計：通用模型
一個模型 → 預測所有股票
├── Random Forest 模型 (1個)
├── Logistic Regression 模型 (1個)
└── 用於預測：2330, 8299, 1301, ... 所有股票

為什麼選擇通用模型？
個別模型的問題：
├── 台積電：可能有足夠資料訓練
├── 小型股：資料不足，模型不穩定
└── 新上市股：幾乎沒有歷史資料

通用模型的優勢：
├── 匯集所有股票的資料
├── 學習整體市場規律
└── 小型股也能受益於大型股的經驗
股票市場的共同特徵：
├── 技術指標邏輯相同 (RSI, 移動平均)
├── 市場情緒影響相似
├── 經濟週期影響一致
└── 投資者行為模式類似
通用模型：
├── 維護成本低 (1個模型 vs 2000+個)
├── 更新簡單
├── 計算資源需求合理
└── 新股票可立即預測

個別模型：
├── 維護成本極高
├── 需要大量計算資源
├── 新股票無法預測
└── 小型股預測不穩定

特徵個別化 vs 模型通用化
為什麼特徵要個別化？
每個股票的特徵不同：
├── 台積電 2024-12-30: RSI=65, 營收成長=20%
├── 群聯 2024-12-30: RSI=59, 營收成長=55%
└── 每個股票在同一時間點的市場狀態不同
為什麼模型要通用化？
預測邏輯是相同的：
├── RSI > 70 → 可能過熱
├── 營收成長 > 20% → 基本面良好  
├── 成交量放大 → 市場關注度高
└── 這些規律對所有股票都適用
類比說明
醫學診斷的例子
❌ 不會這樣做：
├── 為每個病人建立專屬診斷模型
└── 需要10億個模型

✅ 實際做法：
├── 一個通用診斷模型
├── 輸入每個病人的個別症狀
└── 輸出該病人的診斷結果
股票預測的邏輯
✅ 我們的做法：
├── 一個通用預測模型 (學習市場規律)
├── 輸入每個股票的個別特徵
└── 輸出該股票的預測結果
技術層面解釋
模型學習的是什麼？
  # 模型學習的規律 (簡化版)
  if RSI > 70 and 營收成長 < 5%:
      return "看跌"
  elif RSI < 30 and 營收成長 > 20%:
      return "看漲"
  else:
      return "持平"

這些規律對所有股票都適用，所以不需要每個股票建立專屬模型。

預測時的流程
# 預測台積電
features_2330 = [RSI=65, 營收成長=20%, ...]
prediction = universal_model.predict(features_2330)

# 預測群聯  
features_8299 = [RSI=59, 營收成長=55%, ...]
prediction = universal_model.predict(features_8299)

進階設計選項
如果真的要個別化，可能的方案：
1. 行業別模型
├── 科技股模型 (台積電、聯發科...)
├── 金融股模型 (台積電、玉山金...)
├── 傳產股模型 (台塑、中鋼...)
└── 生技股模型 (...)
市值別模型
├── 大型股模型 (市值 > 1000億)
├── 中型股模型 (市值 100-1000億)
└── 小型股模型 (市值 < 100億)
混合模型
├── 通用基礎模型 (學習共同規律)
├── 個股調整因子 (學習個別特性)
└── 最終預測 = 基礎預測 × 調整因子
💡 總結
當前設計的優勢：
✅ 資料效率高 - 充分利用所有股票資料
✅ 維護成本低 - 只需維護一個模型
✅ 泛化能力強 - 新股票也能預測
✅ 穩定性好 - 不會因個別股票資料不足而失效
這就是為什麼：
模型通用 - 學習市場共同規律
特徵個別 - 反映每個股票的當前狀態
預測個別 - 針對每個股票給出專屬預測
這種設計在金融機器學習中是標準做法，平衡了效果、效率和實用性！

